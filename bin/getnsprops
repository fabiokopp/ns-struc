#!/usr/bin/env python

'GETNSPROPS -- calculate NS properties as a function of central density for selected EoSs'
__author__ = 'philippe.landry@ligo.org and Reed Essick (reed.essick@gmail.com)'
__date__ = '03-2019'

#-------------------------------------------------

import os

import numpy as np
from scipy.interpolate import interp1d

from argparse import ArgumentParser

### non-standard libraries
from nsstruc import tov
from nsstruc.constants import rhonuc

#-------------------------------------------------

DEFAULT_NUM_RHOC = 200
DEFAULT_MIN_RHOC = 0.8
DEFAULT_MAX_RHOC = 12.0
DEFAULT_RHOC_RANGE = [DEFAULT_MIN_RHOC, DEFAULT_MAX_RHOC]

DEFAULT_R_STEP = 10 ### cm
DEFAULT_NUM_R = 2000
DEFAULT_MAX_R = 2e6 ### cm
DEFAULT_PRESSUREC2_TOL = 10 ### g/cm^3

#-------------------------------------------------

OUTPATH_TEMPLATE = '%s/macro-%s'
def eospath2macropath(path):
    path = os.path.abspath(path)
    return OUTPATH_TEMPLATE%(os.path.dirname(path), os.path.basename(path))

#-------------------------------------------------

parser = ArgumentParser(description=__doc__)

parser.add_argument('eos', nargs='+', type=str)

parser.add_argument('-p', '--props', nargs='+', type=str, default=tov.DEFAULT_PROPS,
    help='list of NS properties to calculate, DEFAULT=%s'%tov.DEFAULT_PROPS)

parser.add_argument('-n', '--num-rhoc', type=int, default=DEFAULT_NUM_RHOC,
    help='number of central densities to sample per EoS')
parser.add_argument('-r', '--rhoc-range', nargs=2, type=float, default=DEFAULT_RHOC_RANGE,
    help='comma-separated min and max values for central density in units of rhonuc.')

parser.add_argument('-s', '--initial-R', type=float, default=tov.DEFAULT_INITIAL_R,
    help='starting point for radial TOV integration in cm. Should be small.')
parser.add_argument('-N', '--num-R', type=int, default=tov.DEFAULT_NUM_R,
    help='number of points for radial TOV integration')
parser.add_argument('-m', '--max-R', type=float, default=tov.DEFAULT_MAX_R,
    help='radius endpoint in cm for surface finding algorithm')
parser.add_argument('--max-dR', type=float, default=tov.DEFAULT_MAX_DR,
    help='radius endpoint in cm for surface finding algorithm')
parser.add_argument('-T', '--pressurec2-tol', type=float, default=tov.DEFAULT_PRESSUREC2_TOL,
    help='pressure tolerance for surface finding algorithm in g/cm^3')

parser.add_argument('-v', '--verbose', action='store_true', default=False)
parser.add_argument('-V', '--Verbose', action='store_true', default=False,
    help='print how many iterations each integration took')

args = parser.parse_args()

args.verbose |= args.Verbose

for prop in args.props:
    assert prop in tov.KNOWN_PROPS, 'prop=%s not understood!'%prop
if 'R' not in args.props: ### we must have this present because integration termination condition is based on finding R!
    args.props.append('R')
header = 'rhoc,'+','.join(args.props)

min_rhoc, max_rhoc = np.array(args.rhoc_range)*rhonuc

#-------------------------------------------------

### CALCULATE NS PROPERTIES FOR EACH EOS
properties = np.empty((args.num_rhoc, len(args.props)+1), dtype=float) ### place-holder for fixed-sized integration
                                                                       ### FIXME: will want to move this inside the loop for adaptive grid placement...

for eospath in args.eos:
    if args.verbose:
        print('Calculating properties from: %s'%eospath)

    ### load data
    data = np.genfromtxt(eospath, names=True, delimiter=',')
    baryon_density = data['baryon_density']     # rest-mass energy density in units of g/cm^3
    pressurec2 = data['pressurec2']             # pressure in units of g/cm^3
    energy_densityc2 = data['energy_densityc2'] # total energy density in units of g/cm^3

    ### define interpolators
    rho = interp1d(pressurec2, baryon_density, kind='linear', bounds_error=False, fill_value=0)
    eps = interp1d(pressurec2, energy_densityc2, kind='linear', bounds_error=False, fill_value=0)
    cs2i = interp1d(pressurec2, np.gradient(energy_densityc2, pressurec2), kind='linear', bounds_error=False, fill_value=0)
    prs = interp1d(baryon_density, pressurec2, kind='linear', bounds_error=False, fill_value=0)

    ### define integration function, which will be re-used within iteration over rhoc
    efe = tov.define_efe(eps, cs2i, rho, args.props)

    ### define grid for integration
    properties[:,0] = np.linspace(max(min_rhoc, baryon_density[0]), min(max_rhoc, baryon_density[-1]), args.num_rhoc)

    if args.verbose:
        print('Start at central density %.6e g/cm^3'%(properties[0,0]))

    for i, rhoc in enumerate(properties[:,0]): # compute macroscopic properties for star of each central density
        pc = prs(rhoc)
        properties[i,1:] = tov.tov(
            efe,                                                                    ### equations
            tov.initconds(pc, eps(pc), cs2i(pc), rhoc, args.initial_R, args.props), ### initial conditions
            args.initial_R,                                                         ### initial radius
            props=args.props,
            num_r=args.num_R,
            max_dr=args.max_dR,
            pressurec2_tol=args.pressurec2_tol,
            verbose=args.Verbose,
        )

    macropath = eospath2macropath(eospath)
    if args.verbose:
        print('Done at central density %.6e g/cm^3\nSaving: %s'%(properties[-1,-1], macropath))
    np.savetxt(macropath, properties, delimiter=',', comments='', header=header)
